import math

class GCodeGenerator:
    def __init__(self):
        self.current_position = [0, 0, 0]  # X, Y, Z
        self.extruder_position = 0
        
    def generate(self, layers, settings, progress_callback=None):
        """Generate G-code from sliced layers"""
        gcode_lines = []
        
        # Add header
        gcode_lines.extend(self._generate_header(settings))
        
        # Process each layer
        for i, layer in enumerate(layers):
            if progress_callback:
                progress_callback((i / len(layers)) * 100)
                
            gcode_lines.extend(self._generate_layer(layer, i, settings))
            
        # Add footer
        gcode_lines.extend(self._generate_footer())
        
        return '\n'.join(gcode_lines)
        
    def _generate_header(self, settings):
        """Generate G-code header with initialization commands"""
        lines = [
            "; Generated by Python 3D Slicer",
            "; Nozzle temperature: {}°C".format(settings['nozzle_temp']),
            "; Bed temperature: {}°C".format(settings['bed_temp']),
            "; Layer height: {}mm".format(settings['layer_height']),
            "; Print speed: {}mm/s".format(settings['print_speed']),
            "",
            "G21 ; Set units to millimeters",
            "G90 ; Use absolute coordinates",
            "M82 ; Use absolute distances for extrusion",
            "",
            "M104 S{} ; Set nozzle temperature".format(settings['nozzle_temp']),
            "M140 S{} ; Set bed temperature".format(settings['bed_temp']),
            "",
            "G28 ; Home all axes",
            "",
            "M109 S{} ; Wait for nozzle temperature".format(settings['nozzle_temp']),
            "M190 S{} ; Wait for bed temperature".format(settings['bed_temp']),
            "",
            "G92 E0 ; Reset extruder position",
            "G1 F{} ; Set feed rate".format(settings['print_speed'] * 60),
            ""
        ]
        return lines
        
    def _generate_layer(self, layer, layer_num, settings):
        """Generate G-code for a single layer"""
        lines = [
            "",
            "; Layer {}".format(layer_num + 1),
            "G1 Z{:.3f} ; Move to layer height".format(layer.z_height)
        ]
        
        # Update current Z position
        self.current_position[2] = layer.z_height
        
        # Print perimeters first
        for polygon in layer.perimeters:
            lines.extend(self._print_polygon(polygon, settings))
            
        # Print infill
        for infill_line in layer.infill_lines:
            lines.extend(self._print_line(infill_line, settings))
            
        return lines
        
    def _print_polygon(self, polygon, settings):
        """Generate G-code to print a polygon perimeter"""
        lines = []
        
        try:
            coords = list(polygon.exterior.coords)
            
            if len(coords) < 3:
                return lines
                
            # Move to start position without extruding
            start_x, start_y = coords[0]
            lines.append("G1 X{:.3f} Y{:.3f} ; Move to perimeter start".format(start_x, start_y))
            
            # Print perimeter
            for i in range(1, len(coords)):
                x, y = coords[i]
                distance = self._calculate_distance(self.current_position[0], self.current_position[1], x, y)
                extrude_amount = distance * 0.05  # Simple extrusion calculation
                
                self.extruder_position += extrude_amount
                self.current_position[0] = x
                self.current_position[1] = y
                
                lines.append("G1 X{:.3f} Y{:.3f} E{:.5f}".format(x, y, self.extruder_position))
                
        except Exception:
            # Fallback for invalid polygons
            pass
            
        return lines
        
    def _print_line(self, line_coords, settings):
        """Generate G-code to print an infill line"""
        lines = []
        
        if len(line_coords) < 2:
            return lines
            
        # Move to start position
        start_x, start_y = line_coords[0][:2]
        lines.append("G1 X{:.3f} Y{:.3f} ; Move to infill start".format(start_x, start_y))
        
        # Print line segments
        for i in range(1, len(line_coords)):
            x, y = line_coords[i][:2]
            distance = self._calculate_distance(self.current_position[0], self.current_position[1], x, y)
            extrude_amount = distance * 0.03  # Less extrusion for infill
            
            self.extruder_position += extrude_amount
            self.current_position[0] = x
            self.current_position[1] = y
            
            lines.append("G1 X{:.3f} Y{:.3f} E{:.5f}".format(x, y, self.extruder_position))
            
        return lines
        
    def _calculate_distance(self, x1, y1, x2, y2):
        """Calculate distance between two points"""
        return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)
        
    def _generate_footer(self):
        """Generate G-code footer with end commands"""
        lines = [
            "",
            "; End of print",
            "M104 S0 ; Turn off nozzle heater",
            "M140 S0 ; Turn off bed heater",
            "M84 ; Disable motors",
            "G91 ; Relative positioning",
            "G1 Z10 ; Move Z up 10mm",
            "G90 ; Absolute positioning",
            "G1 X0 Y200 ; Move to front",
            "",
            "; Print completed successfully!"
        ]
        return lines


